# graph-goliath

Граф хранится в матрице смежности в файле.
Строки идут друг за другом, значения элементов строки (0 - нет пути, 1 - есть путь) хранятся в битах.
Байт заполняется стандартно, справа налево.
Хранение в битах уменьшает размер файла.

Для поиска пути используется поиск в глубину. Нерекурсивный вариант со стеком.
Для стека используется файл. Там хранятся индексы узлов, каждый в Long (8 байт).
Для алгоритма используется хранилиже пройденных узлов. Информация хранится побитово.

sbt gen-idea
сгенерирует проект для Idea, если нужно.

sbt test
запустит тесты.
один из тестов (gg.graph.GraphSpec) проверяет маленький граф с различными маршрутами.
маршруты в матрице смежности в этом же тесте.

sbt one-jar
соберёт проект в target/scala-2.12/gg_2.12-1.0.jar

собранный файл уже лежит в корне

java -jar gg_2.12-1.0.jar --create-fl 100000
Создаст в текущем каталоге каталог tmp, а в нём файл first-to-last.bbb
с матрицей смежности для графа размером 100 000 узлов.
В файле будет маршрут 1 -> 2 -> 3 -> ... -> n

java -jar gg_2.12-1.0.jar --create-diagonal 100000
Создаст в текущем каталоге каталог tmp, а в нём файл diagonal.bbb
с матрицей смежности для графа размером 100 000 узлов.
В файле по диагонали будут стоять 1. Т.е. каждый элемент будет связан только с самим собой.

Генерация таких больших файлов не оптимизирована и может занимать несколько минут.

Для поиска пути используется команда
java -jar -Xmx30m gg_2.12-1.0.jar имя_файла размерность_графа i j
где
-Xmx30m - максимальный размер кучи. Меньше 30 может вылететь с OoM. Служебные классы много занимают.
имя_файла - имя файла с графом (например tmp/first-to-last.bbb)
размерность_графа - размерность, которая указывалась при генерации
поиск маршрута будет осуществляться от элемента с индексом i до элемента с индексом j

Надо учесть, что время поиска длинного маршрута для графа с 100 000 элементами
может быть очень долгим, т.к. перебираются строки матрицы смежности.
Маршрут с 0 по 100 у меня ищет 30 сек, с 0 по 1000 -
Поэтому лучше искать маршруту между близкими узлами.
Алгоритм ищет циклы (например путь из 0 в 0, при 0 -> 1 -> 2 -> 0),
так что поиск в графе first-to-last.bbb с 100 000 элементами несуществующего маршрута
может быть долгим. В diagonal.bbb размера 100 000 такой поиск будет быстрым.